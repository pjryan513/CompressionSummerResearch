<!DOCTYPE_html>
<html>
  <header>
    <title>Weekly Update 2</title>
  </header>

  <body>



    <h1>
      Weekly Update for week 2
    </h1>

    <h2>
      Structure of Code
    </h2>
    <h3>
      types of bytes
    </h3>
    <p>int value of 0 will represent a 0-fill byte</p>
    <p>int value of 1 will represent a 1-fill byte</p>
    <p>int value of 2 will represent a odd literal byte</p>
    <p>int value of 3 will represent a messy literal byte</p>

    <h3>
      structs to use
    </h3>
    <p>based off of the struct used for WAH and VAL we will make a similar blockSeg struct but based around bytes instead of 32-bit words</p>
    <p>We could use a similar name, such as "struct BBCseg". The struct would contain:
    <ul>
      <li>Header byte of the current run. The header contains important information, which we can extract:</li>
      <ul>
        <li>Fill length</li>
        <li>Tail length</li>
        <li>Run type</li>
      </ul>
      <li>Pointer to next block</li>
      <li>Pointer to file containing compressed data</li>
      <li>current (uncompressed) byte</li>
      <li>current (uncompressed) byte type (as described above)</li>
    </ul>
    </p>



    <h3>
      where and what to add
    </h3>
    <p>Have to add or use loop in RawBitmapReader.c to include a call to our bbc</p>
    <p>Add bbc section to control.h</p>
    <p>BBCCompressor.c (where we will implement the BBC algorithm)</p>
    <p>BBCCompressor.h </p>
    <p>

    <h2>
      Psuedo Code for BBC
    </h2>
    <p>get next byte from raw seq</p>
    <p>determine type of byte</p>
    <p>call header byte or lastByte</p>
    <ul>
      <li>update header byte</li>
      <ul>
        <li>update fill length</li>
        <li>update tail length</li>
      </ul>
      <li>change type of run</li>
      <li>end run</li>
    </ul>
    <p>if byte is new head or literal</p>
    <ul>
      <p>add to bbc</p>
    </ul>


    <h2>
      Revisted Psudeo Code
    </h2>
    <p>while(raw bit seq has next byte)</p>
    <ul>
      <p>get next byte</p>
      <p>int next = getType(next byte)</p>
      <p>if(next == 0)</p>
      <ul>
        char header = updateHeader(0)
        <p>if(new run)</p>
        <ul>
          startNewRun(next byte)
        </ul>
        <p>else if(run = Type 1)</p>
        <ul>
          <p>updateHeader(0)
        </ul>
        <p>else if()
      </ul>
      <p>if(next==1)</p>
      <p>if(next==2)</p>
      <ul>
      <li>if fill <= 3</li>
        <ul>
        <li>Change to type 2 run and finish the run</li>
        </ul>
      <li>else</li>
        <ul>
        <li>Change to type 4 run and finish the run</li>
        </ul>
      </ul>
      </p>
      <p>if(next==3)</p>
    </ul>

    
    <h2>
    Questions and Concerns:
    </h2>
      <p>
        <ul>
        <li>Suppose we have a long tail of messy bits, then we come across an odd byte.
        Should we append the odd byte to the tail, or start a new type 2 or 4 run to
        contain the single odd bit? Possible overhead concerns with implementing this special
        case vs. the rarity of the special case given sparse data.</li>
        </ul>
      </p>
  </body>
</html>
